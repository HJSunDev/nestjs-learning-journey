version: '3.8'

# ============================================================
# 服务组说明：
# - 基础设施服务：postgres, redis（无 profile，始终可用）
# - 开发工具服务：pgadmin, redis-insight（dev profile）
# - 应用服务：app（prod profile）
# 
# 使用方式：
# - 本地开发：docker compose --profile dev up -d（数据库 + 可视化工具）
# - 生产部署：docker compose --profile prod up -d --build（应用 + 数据库）
# - 仅数据库：docker compose up -d（最简模式）
# ============================================================

services:
  # === NestJS 应用服务 ===
  # 仅在 prod profile 下启动
  app:
    profiles: [prod]
    build:
      context: .
      dockerfile: Dockerfile
    container_name: nest-journey-app
    restart: unless-stopped
    
    # 端口映射：宿主机 3000 -> 容器 3000
    ports:
      - "${APP_PORT:-3000}:${APP_PORT:-3000}"
    
    # 环境变量配置
    environment:
      # 应用配置
      APP_ENV: ${APP_ENV:-production}
      APP_PORT: ${APP_PORT:-3000}
      
      # 数据库配置（容器网络内使用服务名作为主机名）
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: ${DB_NAME}
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASS}
      DB_SYNCHRONIZE: "false"
      DB_LOGGING: ${DB_LOGGING:-false}
      
      # Redis 配置（容器网络内使用服务名作为主机名）
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_DB: ${REDIS_DB:-0}
      
      # JWT 配置
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      JWT_ACCESS_EXPIRES_IN: ${JWT_ACCESS_EXPIRES_IN:-15m}
      JWT_REFRESH_EXPIRES_IN: ${JWT_REFRESH_EXPIRES_IN:-7d}
      
      # 存储配置
      STORAGE_DRIVER: ${STORAGE_DRIVER:-local}
      STORAGE_LOCAL_DIR: ${STORAGE_LOCAL_DIR:-static/upload}
      STORAGE_LOCAL_PREFIX: ${STORAGE_LOCAL_PREFIX:-/static/upload}
      
      # CORS 配置
      CORS_ORIGINS: ${CORS_ORIGINS:-}
      
      # 日志配置
      LOG_LEVEL: ${LOG_LEVEL:-warn}
      LOG_ON_CONSOLE: ${LOG_ON_CONSOLE:-false}
    
    # 依赖服务：确保数据库和 Redis 先启动
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    
    # 健康检查（使用 Dockerfile 内置的 HEALTHCHECK，此处可覆盖）
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:${APP_PORT:-3000}/health/liveness"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    
    # 资源限制（可选，生产环境建议开启）
    # deploy:
    #   resources:
    #     limits:
    #       cpus: '1'
    #       memory: 512M
    #     reservations:
    #       cpus: '0.5'
    #       memory: 256M

  # === PostgreSQL 服务 ===
  postgres:
    # 镜像：使用官方 PostgreSQL 16 镜像（当前最新稳定版）
    image: postgres:16
    
    # 容器名称：带上项目前缀，避免与其他项目冲突 给运行起来的进程起个名，方便查找
    container_name: nest-journey-postgres
    
    # 自动重启：如果你重启电脑或 Docker，数据库会自动重新启动
    restart: always
    
    # 环境变量：设置初始的超级用户账号和默认数据库
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    
    # 端口映射
    # 格式："宿主机端口:容器内部端口"
    # PostgreSQL 默认端口是 5432  将电脑的 5432 端口流量，通过网桥转发给容器内的 5432 端口
    ports:
      - "5432:5432"
    
    # 数据挂载 
    # 格式："宿主机路径:容器内部路径"
    # 作用：将容器里存数据的 /var/lib/postgresql/data 目录，直接映射到你当前项目下的 ./postgres-data 文件夹
    # 结果：你的数据实际上是存在你眼前的项目文件夹里的，而不是藏在 Docker 里的
    # PostgreSQL 数据目录是 /var/lib/postgresql/data
    volumes:
      - ./postgres-data:/var/lib/postgresql/data
    
    # 健康检查：用于 app 服务的 depends_on condition
    healthcheck:
      # 使用容器内环境变量，避免宿主机未注入 DB_* 时健康检查失效
      # 这里需要用 $$ 转义，否则 docker compose 会把 $POSTGRES_* 当作宿主机变量插值
      test: ["CMD-SHELL", "pg_isready -U \"$$POSTGRES_USER\" -d \"$$POSTGRES_DB\""]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # === pgAdmin 服务 (Web管理端) ===
  # 仅在 dev profile 下启动
  pgadmin:
    profiles: [dev]
    image: dpage/pgadmin4
    container_name: nest-journey-pgadmin
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: "admin@admin.com"
      PGADMIN_DEFAULT_PASSWORD: "admin"
    ports:
      - "5050:80"
    # 持久化配置，避免每次重启都要重新添加服务器连接
    volumes:
      - ./pgadmin-data:/var/lib/pgadmin
    depends_on:
      - postgres

  # === Redis 服务 ===
  redis:
    # 镜像：使用官方 Redis 7.2 版本 (目前较新的稳定版)
    image: redis:7.2
    
    # 容器名称
    container_name: nest-journey-redis
    
    # 自动重启
    restart: always
    
    # 启动命令：开启 AOF 持久化 (默认是关闭的，开启后数据更安全)
    # --requirepass 使用环境变量 ${REDIS_PASSWORD}
    # --maxmemory 512mb: 限制最大内存使用量
    # --maxmemory-policy allkeys-lru: 内存满时的淘汰策略
    command: redis-server --appendonly yes --requirepass "${REDIS_PASSWORD}" --maxmemory 512mb --maxmemory-policy allkeys-lru
    
    # 端口映射：宿主机 6379 -> 容器 6379
    ports:
      - "6379:6379"
    
    # 数据挂载：把 Redis 数据存在当前目录下的 ./redis-data 文件夹
    volumes:
      - ./redis-data:/data

  # === Redis Insight 服务 (Web管理端) ===
  # 仅在 dev profile 下启动
  redis-insight:
    profiles: [dev]
    image: redis/redisinsight:latest
    container_name: nest-journey-redis-insight
    restart: always
    ports:
      - "5540:5540"
    # 持久化配置，避免每次重启都要重新添加 Redis 连接
    volumes:
      - ./redis-insight-data:/data
    depends_on:
      - redis
